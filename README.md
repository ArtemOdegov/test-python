# Мини-CRM распределения лидов между операторами

Система автоматического распределения обращений лидов от различных источников (ботов) между операторами с учетом весов (компетенций) и лимитов нагрузки.

## Технологический стек

- **Python** 3.8+
- **FastAPI** - современный веб-фреймворк для создания API
- **SQLAlchemy** (async) - ORM для работы с базой данных
- **SQLite** - файловая база данных (создается автоматически)

## Быстрый старт

### Установка зависимостей

```bash
pip install -r requirements.txt
```

### Запуск приложения

```bash
uvicorn main:app --reload
```

Или:

```bash
python main.py
```

После запуска приложение будет доступно по адресу:
- API: http://localhost:8000
- Документация (Swagger UI): http://localhost:8000/docs
- Альтернативная документация (ReDoc): http://localhost:8000/redoc

## Структура модели данных

### Основные сущности

#### 1. **Operator (Оператор)**
Представляет оператора, который обрабатывает обращения от лидов.

**Поля:**
- `id` - уникальный идентификатор
- `name` - имя оператора
- `is_active` - флаг активности (может ли получать новые обращения)
- `max_load` - максимальное количество активных обращений (лимит нагрузки)
- `created_at` - дата создания

**Связи:**
- Имеет связи с источниками через `SourceOperatorWeight` (веса)
- Имеет множество обращений (`Contact`)

#### 2. **Source (Источник/Бот)**
Представляет источник обращений (канал, из которого пришло обращение).

**Поля:**
- `id` - уникальный идентификатор
- `name` - название источника (уникальное)
- `description` - описание (опционально)
- `created_at` - дата создания

**Связи:**
- Имеет связи с операторами через `SourceOperatorWeight` (веса для распределения)
- Имеет множество обращений (`Contact`)

#### 3. **SourceOperatorWeight (Вес оператора по источнику)**
Связующая таблица между источниками и операторами, определяющая веса (компетенции) для распределения.

**Поля:**
- `id` - уникальный идентификатор
- `source_id` - ID источника
- `operator_id` - ID оператора
- `weight` - вес (числовое значение для расчета вероятности выбора)

**Логика:**
- Если оператор1 имеет вес 10, а оператор2 - вес 30, то оператор2 будет получать примерно 75% обращений (30/(10+30)), а оператор1 - 25% (10/(10+30))

#### 4. **Lead (Лид)**
Представляет конечного клиента, который может обращаться через разные источники.

**Поля:**
- `id` - уникальный идентификатор
- `external_id` - внешний идентификатор из системы источника (опционально)
- `phone` - телефон для идентификации лида (опционально)
- `email` - email для идентификации лида (опционально)
- `name` - имя лида (опционально)
- `created_at` - дата создания

**Связи:**
- Имеет множество обращений (`Contact`), каждое из которых может быть из разного источника

#### 5. **Contact (Обращение/Контакт)**
Конкретный факт обращения лида из определенного источника.

**Поля:**
- `id` - уникальный идентификатор
- `lead_id` - ID лида
- `source_id` - ID источника, из которого пришло обращение
- `operator_id` - ID назначенного оператора (может быть NULL, если оператор не найден)
- `status` - статус обращения (по умолчанию "active")
- `message` - текст обращения или дополнительные данные (опционально)
- `created_at` - дата создания

**Связи:**
- Принадлежит одному лиду (`Lead`)
- Принадлежит одному источнику (`Source`)
- Может быть назначен оператору (`Operator`)

### Диаграмма связей

```
Source (1) ──< (N) SourceOperatorWeight (N) ──> (1) Operator
                                                      │
                                                      │ (1)
                                                      │
                                                 (N) Contact
                                                      │
                                                      │ (N)
                                                      │
                                                    (1) Lead
```

## Алгоритм распределения обращений

### 1. Определение лида

При создании нового обращения система ищет существующего лида в следующем порядке приоритета:

1. По `external_id` (если указан) - точное совпадение
2. По `phone` (если указан) - точное совпадение
3. По `email` (если указан) - точное совпадение

Если лид не найден ни по одному из критериев, создается новый лид.

**Важно:** Один и тот же лид может иметь несколько обращений из разных источников. Если лид ранее обращался из источника A, а затем из источника B, оба обращения будут связаны с одним лидом.

### 2. Определение доступных операторов

Для каждого источника настроена конфигурация операторов с весами. При выборе оператора система:

1. Загружает всех операторов, назначенных на данный источник с их весами
2. Фильтрует операторов по условиям:
   - Оператор должен быть активен (`is_active = True`)
   - Текущая нагрузка оператора (количество активных обращений со статусом "active") не должна превышать лимит (`max_load`)

### 3. Распределение с учетом весов

После фильтрации доступных операторов система использует **взвешенный случайный выбор** (weighted random):

1. Вычисляется сумма всех весов доступных операторов: `total_weight = sum(weights)`
2. Генерируется случайное число от 0 до `total_weight`
3. Выбирается оператор на основе кумулятивных весов:
   - Операторы размещаются в порядке их весов
   - Создается кумулятивная сумма весов
   - Выбирается первый оператор, для которого кумулятивная сумма >= случайное число

**Пример:**
- Оператор1: вес 10
- Оператор2: вес 30
- Сумма: 40

Генерируется случайное число от 0 до 40:
- Если число <= 10 → Оператор1
- Если число > 10 и <= 40 → Оператор2

В долгосрочной перспективе это обеспечивает распределение примерно 25% / 75%.

### 4. Учет лимитов нагрузки

**Нагрузка оператора** определяется как количество активных обращений со статусом "active".

При выборе оператора система проверяет, не превышает ли текущая нагрузка лимит `max_load`. Если оператор "выиграл" в случайном выборе, но его лимит уже исчерпан, такой оператор не участвует в выборе (он был отфильтрован на этапе определения доступных операторов).

### 5. Обработка отсутствия подходящих операторов

Если после всех проверок не найдено ни одного подходящего оператора (все неактивны или все превысили лимит), система:

- **Создает обращение без оператора** (`operator_id = NULL`)
- Обращение получает статус "active"
- В дальнейшем такое обращение можно будет обработать вручную или автоматически, когда появятся доступные операторы

Обращение без оператора можно получить через API и назначить оператора вручную, изменив статус или обновив запись.

## API Endpoints

### Управление операторами

- `POST /operators/` - Создать оператора
- `GET /operators/` - Список всех операторов
- `GET /operators/{id}` - Получить оператора по ID
- `PATCH /operators/{id}` - Обновить оператора (активность, лимит)
- `DELETE /operators/{id}` - Удалить оператора
- `GET /operators/{id}/stats` - Статистика по оператору (нагрузка, утилизация)

### Управление источниками

- `POST /sources/` - Создать источник
- `GET /sources/` - Список всех источников
- `GET /sources/{id}` - Получить источник с конфигурацией операторов
- `POST /sources/{id}/operators` - Добавить оператора к источнику с весом
- `PATCH /sources/{id}/operators/{operator_id}` - Обновить вес оператора
- `DELETE /sources/{id}/operators/{operator_id}` - Удалить оператора из источника

### Регистрация обращений

- `POST /contacts/` - Создать новое обращение (автоматически найдет/создаст лида и выберет оператора)
- `GET /contacts/` - Список обращений (с фильтрацией по lead_id, source_id, operator_id)
- `GET /contacts/{id}` - Получить обращение по ID
- `PATCH /contacts/{id}/status` - Изменить статус обращения

### Просмотр лидов

- `GET /leads/` - Список лидов
- `GET /leads/{id}` - Получить лида со всеми его обращениями

### Статистика

- `GET /stats/sources/{id}` - Статистика распределения обращений по операторам для источника

## Примеры использования

### 1. Создание операторов

```bash
curl -X POST "http://localhost:8000/operators/" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Оператор 1",
    "is_active": true,
    "max_load": 10
  }'
```

### 2. Создание источника

```bash
curl -X POST "http://localhost:8000/sources/" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Telegram Bot",
    "description": "Бот в Telegram"
  }'
```

### 3. Настройка распределения

```bash
# Назначить оператора 1 на источник 1 с весом 10
curl -X POST "http://localhost:8000/sources/1/operators" \
  -H "Content-Type: application/json" \
  -d '{
    "operator_id": 1,
    "weight": 10
  }'

# Назначить оператора 2 на источник 1 с весом 30
curl -X POST "http://localhost:8000/sources/1/operators" \
  -H "Content-Type: application/json" \
  -d '{
    "operator_id": 2,
    "weight": 30
  }'
```

### 4. Создание обращения

```bash
curl -X POST "http://localhost:8000/contacts/" \
  -H "Content-Type: application/json" \
  -d '{
    "source_id": 1,
    "lead_external_id": "user123",
    "lead_phone": "+79991234567",
    "lead_name": "Иван Иванов",
    "message": "Хочу узнать о продукте"
  }'
```

Система автоматически:
- Найдет или создаст лида по `external_id` или `phone`
- Выберет оператора по алгоритму распределения
- Создаст обращение

### 5. Просмотр статистики

```bash
# Статистика по источнику
curl "http://localhost:8000/stats/sources/1"

# Статистика по оператору
curl "http://localhost:8000/operators/1/stats"
```

## Примечания

- База данных SQLite создается автоматически в файле `crm.db` при первом запуске
- Все временные метки хранятся в UTC
- Статусы обращений можно менять (например, "active" → "closed") для освобождения нагрузки оператора
- Веса операторов могут быть любыми положительными числами, включая дробные

## Разработка

Проект использует async/await для всех операций с базой данных, что обеспечивает хорошую производительность. Структура проекта:

```
.
├── main.py              # Точка входа FastAPI приложения
├── database.py          # Настройка подключения к БД
├── models.py            # SQLAlchemy модели
├── schemas.py           # Pydantic схемы для валидации
├── distribution.py      # Логика распределения обращений
├── routers/             # API роутеры
│   ├── operators.py
│   ├── sources.py
│   ├── contacts.py
│   ├── leads.py
│   └── stats.py
├── requirements.txt     # Зависимости
└── README.md           # Документация
```

